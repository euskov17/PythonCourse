## BIN MIN

`control flow` `binary search` `list` `len` `//` `job interview`

### Условие

Найти минимум в отсортированном по возрастанию, а затем циклически сдвинутом массиве из целых чисел.
Гарантируется, что массив не пустой, и что в нем нет дубликатов.

* Постарайтесь сразу до написания ответить на вопрос, что лучше в данном контексте for или while
* Постарайтесь написать самым читабельным способом
* Оцените сложность по времени и памяти - у вас должно получится О(log n) и O(1)
* Не модицируйте вход, это плохая практика, если это не нужно
* Обратите внимание, что минимум есть всегда, поэтому `return` в цикле достаточно, и его не нужно ставить в конце функции
* Для того, чтоб mypy справлялся с распознаванием типа в конце функции, рекомендуем ставить конструкцию вида `assert False, "Not reachable"`

Подумайте, как поменялась бы сложность, если б в массиве были дубликаты?

### Пример

```python
>>> find_min([5, 6, 7, 1, 2, 3, 4])
1
```

### Про задачу

Это модификация бинпоиска, когда надо подумать над свойствами последовательности. Обвязка такая же, как везде, но
немного иные правила выбора направления. 

Эту задачу не решает больше трети собеседуемых, у которых ее спрашивают.

Обратите внимание, тесты сделаны через примитивную реализацию функции нахождения минимума. Это вполне валидный вариант
тестирования, если нужно получить идентичную функциональность.

### Рассуждение на тему `assert False, "Not reachable"`

У нас есть задача:
* не путать читателя, что из функции можно выйти мимо `while` (не пишем `return`)
* чтоб mypy замолчал в этом случае (надо что-то написать)
* не путать читателя, что может вылететь исключение (не пишем `Exception`)

Читабельный вариант - писать `assert not "Reachable”`.
В задачке `make_assert` разбирается, что пишем assert при проверке того, чего не может случиться в принципе. 
Это как раз тот случай.

### Подсказка

Подумайте в какую сторону вам нужно идти, если левый край последовательности меньше текущего значения?